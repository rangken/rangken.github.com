<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Effective Java 5장 제네릭</title>
    <!-- SEO -->
    <meta name="description" content="제네릭 (23~29)">
    <meta name="keywords" content="Java, effective-java, Java"/>
    <meta name="author" content="Young.k">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://rangken.github.io/blog/2015/effective-java-4/">

    <script>(function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&appId=873345849376888&version=v2.0";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>

    <!-- Google analytics -->
    <script>
  		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  		ga('create', 'UA-58142397-1', 'auto');
  		ga('send', 'pageview');
    </script>
    <script data-ad-client="ca-pub-9512351571435208" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>


  <body>

    <header class="site-header">
  <div class="wrapper">
    <img style="float: left" src="/img/jaeyoung.png" />
    <a class="site-title" href="/">
      <div style="float: left; margin-left: 30px;">YOUNG.K<div>
    </a>
    <div style="float: left; width:500px;">
      <a style="float: left;" class="post-link" href="http://rangken.gitbooks.io/nextersstudy1/content/">
        <h4 style="color:#ffffff;"> Study </h4>
      </a>
      <a style="float: left; margin-left: 10px;" class="post-link" href="http://nexters.github.io/Node-Study/">
        <h4 style="color:#ffffff;"> Node.js </h4>
      </a>
      <a style="float: left; margin-left: 10px;" class="post-link" href="http://rangken.gitbooks.io/javastudy/content/index.html">
        <h4 style="color:#ffffff;"> Effective-Java </h4>
      </a>
    </div>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Effective Java 5장 제네릭</h1>
    <p class="post-meta">Jan 7, 2015
      
	 </p>
  </header>

  <article class="post-content">
    <h2 id="제네릭-2329">제네릭 (23~29)</h2>
<ul>
  <li>자바 1.5 부터  가능
    <ul>
      <li>그전에는 컬랙션에서 객체를 읽어낼때마다 형변환을 해야했다.</li>
      <li>컬랙션에 이상한거 넣어서 에러나고 그랬음(컴파일 타임에서 에러를 검출 못했다)</li>
    </ul>
  </li>
</ul>

<h3 id="item23--새코드에는-무인지-제네릭-자료형을-사용하지-마라">ITEM23 : 새코드에는 무인지 제네릭 자료형을 사용하지 마라</h3>
<ul>
  <li>용어
    <ul>
      <li>형인자(type parameter) :</li>
      <li>형인자 자료형(parameterized type) : List &lt;String&gt;</li>
      <li>실형인자(actual type parameter) : String</li>
      <li>제네릭 자료형(generic type) : List&lt;E&gt;</li>
      <li>형식 형인자(Formal Type Parameter) : E</li>
      <li>무인자 자료형(raw type) : List</li>
      <li>한정적 형인자(bunded type parameter) : &lt;E extends Number&gt;</li>
      <li>재귀적 형 한정(recursive type bound) : &lt;T extends Comparable&lt;T&gt;&gt;</li>
      <li>비한정적 와일드카드 자료형(unbounded wildcard type) : List&lt;?&gt;</li>
      <li>한정적 와일드카드 자료형(bounded wildcard type) : List&lt;? extends Number&gt;</li>
      <li>제네릭 메서드(generic method) : static <E> List<E> asList(E[] a)</E></E></li>
      <li>자료형 토큰(type token) : String.class
  -</li>
    </ul>
  </li>
  <li>제네릭(Generic) : 형인자가 포함된 클래스나 인터페이스
    <ul>
      <li>List 인터페이스는 List&lt;E&gt; 이렇게 부르는게 맞다</li>
      <li>List&lt;String&gt; : 스트링 인터페이스</li>
    </ul>
  </li>
  <li>무인자 자료형은 사용하면 안된다. 컴파일 타임에서 타입 안정성을 보장할수 없다. (ClassCastException 발생 함)
    <ul>
      <li>size 무인자 자료형은 아직도 지원하긴한다. 무인자 자료형을 인자로 받는 메서드에 형인자 자료형 객체를 전달할수 있어야 하고 반대도 가능해야 한다. 이진 호환성을 지원하기 위해 어쩔수 없이 존재한다.</li>
    </ul>
  </li>
  <li>
    <p>형인자 자료형을 사용하면 엉뚱한 자료형의 객체를 넣는 코드를 컴파일 할때 무엇이 잘못인지 알수 있다. 컬랙션에서 원소를 꺼낼떄 형변환을 하지않아도 된다. (컴파일러가 알아서 해줌)</p>
  </li>
  <li>List vs List&lt;Object&gt;
    <ul>
      <li>List 는 완전히 형검사 절차를 생략한것이고 List&lt;Object&gt; 는 형검사를 진행한다</li>
      <li>List 에는 String 을 넣을수 있지만 List&lt;Object&gt; 에는 넣을수 없다.</li>
      <li>List 에는 메서드에 List&lt;String&gt; 을 전달 가능하지만 List&lt;Object&gt; 는 불가능하다</li>
      <li>List&lt;String&gt; 은 List 의 하위자료형(subtype) 이지만 <strong>List&lt;Object&gt;의 하위 자료형은 아니다</strong></li>
      <li>List 와 같은 무인자 자료형을 사용하면 형 안전성을 잃게 되지만 List&lt;Object&gt; 와 같은 형인자 자료형은 형안전성이 있다.</li>
    </ul>
  </li>
  <li>실행 도중 오류를 일으키는 무인자 자료형(List)</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span> <span class="n">strings</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;();</span>
    <span class="n">unsafeAdd</span><span class="o">(</span><span class="n">strings</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Ineger</span><span class="o">(</span><span class="mi">42</span><span class="o">));</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">strings</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// ClassCastException 발생!!!!</span>
<span class="o">}</span>
<span class="c1">// 무인자 자료형에 인자로 보낼수는 있음</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">unsafeAdd</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">o</span><span class="o">){</span>
    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// 경고 발생 unchecked call to add(E) in raw type List</span>
<span class="o">}</span>
<span class="c1">// unsafeAdd(List&lt;Object&gt;... 로 바꾸어야 한다)</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>비한정적 와일드 카드 자료형
    <ul>
      <li>제네릭 자료형을 쓰고 싶으나 실제형인자가 무엇인지는 모르거나 신경쓰고 싶지 않을때는 형인자로 <strong>?</strong> 를 쓰면된다.</li>
      <li>Set&lt;?&gt; : 가장 일반적인 형인자 Set 자료형</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="c1">//static int numElementsInCommon(Set s1, Set s2) { // 무인자 사용하면안된다</span>
<span class="kd">static</span> <span class="kt">int</span> <span class="nf">numElementsInCommon</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;?&gt;</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;?&gt;</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 비한정적 와일드 카드 자료형</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o1</span> <span class="o">:</span> <span class="n">s1</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="mo">01</span><span class="o">)){</span>
            <span class="n">result</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">resultt</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>와일드 카드 자료형은 안전, 무인자자료형은 안전하지 않다.</li>
  <li>
    <p>무인자 자료형에는 아무거나 넣을수 있어서 자료형 불변식이 쉽게 깨진다. Collection&lt;?&gt; 에는 null 이외에 어떤원소도 넣을수가 없다. 무언가 넣을려고 하면 컴파일 오류가 난다. 어떤 자료형 객체를 꺼낼수 있는지도 알수없다.</p>
  </li>
  <li>무인자 자료형을 그래도 써도 되는경우
    <ul>
      <li>클래스 리터럴(class literal)
        <ul>
          <li>자바 표준에서 클래스 리터럴에는 형인자 자료형을 쓸수 없다.(배열 자료형이나 기본 자료형은 쓸수있다)</li>
          <li>List.class, String[].class int.class 는 가능하다</li>
          <li>List&lt;String&gt;.class 나 List&lt;?&gt;.class 는 사용할수가 없다.</li>
        </ul>
      </li>
      <li>instanceOf 연산자 사용규칙
        <ul>
          <li>제네릭 자료형 정보는 프로그램이 실행될때는 지워지므로 instanceOf 연산자는 형인자 자료형에 적용할수가없다. 비한정적 와일드 카드 자료형은 가능하다. 하지만 코드만 지저분해질뿐 굳이 쓸이유가없다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Set</span><span class="o">){</span> <span class="c1">// 무인자 자료형</span>
    <span class="nc">Set</span><span class="o">&lt;?&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Set</span><span class="o">&lt;?&gt;)</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 와일드 카드 자료형</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="item24--무검검-경고unchecked-warning를-제거하라">ITEM24 : 무검검 경고(unchecked warning)를 제거하라</h3>
<ul>
  <li>제네릭을 사용해서 프로그램을 작성하면 컴파일 경고 메세지를 많이 보게 됨
    <ul>
      <li>unchecked 캐스트 경고</li>
      <li>unchecked 메소드 호출 경고</li>
      <li>unchecked 제네릭 배열 생성 경고</li>
      <li>unchecked 변환 경고</li>
    </ul>
  </li>
  <li>unchecked 예외를 무시하면 ClassCastException 가 생길수 있으므로 조심한다.</li>
  <li>@SuppressWarnings(“unchecked”) 주석을 사용해서 경고 메세지를 안나타나게 억제할수 있다.
    <ul>
      <li>다양한 범위로 사용 가능하다. 가급적 제일 작은 범위로 사용하도록 해야한다.</li>
      <li>가능한 주석으로 SuppressWarnings을 사용하는 이유를 남겨라!</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="c1">// ArrayList 의 toArray 함수</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">toArray</span><span class="o">(</span><span class="no">T</span><span class="o">[]</span> <span class="n">a</span><span class="o">){</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">){</span>
        <span class="c1">// unchecked cast (Object[] , required: T[])</span>
        <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span> <span class="no">T</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">CopyOf</span><span class="o">(</span><span class="n">elements</span><span class="o">,</span> <span class="n">size</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="c1">// return 문제  @SuppresseWarnings 를 사용할수 없다.</span>
        <span class="c1">//return (T[])Arrays.CopyOf(elements, size, a.getClass());</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">elements</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="n">size</span><span class="o">)</span>
        <span class="n">a</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="item25--배열-대신-리스트를-써라">ITEM25 : 배열 대신 리스트를 써라</h3>
<ul>
  <li>배열(Array) vs 제네릭 타입
    <ul>
      <li>배열 공변(covariant)이다. Sub 이 Super 의 서브타입이라면 Sub[] 은 Super[]의 서브 타입이다.</li>
      <li>제네릭은 불변(invariant)이다. Type1 Type2 List&lt;Type1&gt; List&lt;Type2&gt; 의 서브타입도 슈퍼타입도 아니다.</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre>    <span class="c1">// 런타임에서 에러 발생</span>
    <span class="nc">Object</span><span class="o">[]</span> <span class="n">objectArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Long</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
    <span class="n">objectArray</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"I don't fit in"</span><span class="o">;</span> <span class="c1">// ArrayStoreException 예외 발생</span>
    <span class="c1">// 컴파일 에러! 컴파일 에러가 더 안전하고 좋은것!</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">ol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;();</span> <span class="c1">// 호환이 안되는 타입이다!</span>
    <span class="n">ol</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"I don't fit in"</span><span class="o">);</span>
    
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>배열은 구체적(reified) : 자신의 요소타입을 런타임시에 알고 지키게 한다. String 객체를 Long 배열에 저장 하려고 하면 런타임에서 ArrayStoreException 예외 발생</li>
  <li>
    <p>제네릭은 소거자(Erasure) 에 의해 구현됨. 컴파일 시에만 자신의 타입 제약을 지키게 하고 런타임 시에는 자신의 요소타입 정보를 무시(소거) 한다.</p>
  </li>
  <li>new List&lt;E&gt;[], new List&lt;Sting&gt;[] , new E[] 와 같은 배열 생성식은 불가
    <ul>
      <li>제네릭 배열 생성은 불가</li>
    </ul>
  </li>
  <li>E, List&lt;E&gt;, List&lt;String&gt; 과 같은 타입들을 비구체화(nonreifiable) 타입 이라고한다.
    <ul>
      <li>비구체화 타입이란 컴파일 시보다 런타임 시에 더 적은 정보를 갖는</li>
      <li>비구체화 타입은 배열 생성이 불가능</li>
      <li>List&lt;?&gt;, Map&lt;?,?&gt; 와 같은 언바운드 와일드 카드 타입은 구체화 타입이다. 따라서 배열 생성 하는건 적법함</li>
      <li>따라서 제네릭 타입을 가변인자를 갖는 메소드와 함께 사용 불가능,가변인자는 내부적으로 배열이 생성되는 구조이기 때문</li>
    </ul>
  </li>
  <li>제네릭 배열 생성 에러가 발생하면 E[] 보다는 List<E> 를 사용하는것이 좋다</E></li>
  <li>다중 스레드간에 동기화에 제네릭 배열이 좋다.</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="c1">// 제네릭을 사용하지 않으면서 동시성에도 결함이 없다.</span>
<span class="c1">// synchronized(list) 로 전체를 묶는 방법이 있지만 동기화된 코드에서는 외계인(alien) 메소드(apply) 를 호출 하면안된다.</span>
<span class="c1">// 따라서 lock 이걸로는 toArray() 를 사용해서 문제를 해결했다.</span>
<span class="kd">static</span> <span class="nc">Object</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Functon</span> <span class="n">f</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">initVal</span><span class="o">){</span>
    <span class="nc">Object</span><span class="o">[]</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span> <span class="c1">// 내부적으로 List 에 lock 이 걸림</span>
    <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">initVal</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">snapshot</span><span class="o">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">o</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="no">E</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Functon</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">,</span> <span class="no">E</span> <span class="n">initVal</span><span class="o">){</span>
    <span class="c1">// 타입 안정성이 보장되지 않는다. 런타임시에 E 가 무슨 타입이 될지 컴파일러가 알지 못한다.</span>
    <span class="c1">// ClassCastException 예외가 발생할수 있다.</span>
    <span class="c1">// 컴파일 시에는 String[] Integer[] 등 아무거나 될수있지만 런타임에서는 Object[] 이므로 위험</span>
    <span class="c1">// E[] 로 캐스팅 하는건 특별한 상황에서만 고려 되야함</span>
    <span class="no">E</span><span class="o">[]</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="o">(</span><span class="no">E</span><span class="o">[])</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">();</span>
    <span class="no">E</span> <span class="n">result</span> <span class="o">=</span> <span class="n">initVal</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="no">E</span> <span class="n">o</span> <span class="o">:</span> <span class="n">snapshot</span><span class="o">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">o</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>


<span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="no">E</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Functon</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">,</span> <span class="no">E</span> <span class="n">initVal</span><span class="o">){</span>
    <span class="no">E</span><span class="o">[]</span> <span class="n">snapshot</span><span class="o">;</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// toArray 함수와는 다르게 락이 걸리지 않으므로 synchronized 함수로 변경해야한다.</span>
        <span class="n">snapshot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;(</span><span class="n">list</span><span class="o">);</span> <span class="c1">// 배열보다는 ArrayList&lt;E&gt;</span>
    <span class="o">}</span>
    <span class="no">E</span> <span class="n">result</span> <span class="o">=</span> <span class="n">initVal</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="no">E</span> <span class="n">o</span> <span class="o">:</span> <span class="n">snapshot</span><span class="o">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">o</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="item26--가능하면-제네릭-자료형으로-만들-것">ITEM26 : 가능하면 제네릭 자료형으로 만들 것</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="code"><pre><span class="c1">// Object 객체 기반의 컬랙션</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Stack</span><span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">elements</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Stack</span><span class="o">(){</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="nc">Object</span> <span class="n">e</span><span class="o">){...}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">pop</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">EmptyStackException</span><span class="o">();</span>
        <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">elements</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
        <span class="n">elements</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 쓸모없는 참조 제거</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 제네릭 적용1 - 캐스팅 이용</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;{</span>
    <span class="kd">private</span> <span class="no">E</span><span class="o">[]</span> <span class="n">elements</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>

    <span class="c1">// E[] 로 캐스팅 하므로 warning 이 발생한다.</span>
    <span class="c1">// elements 는 private 로써 밖에서는 사용이 안되므로 해당 캐스팅만 문제없으면 외부적으로도 문제 없으므로, 아래처럼 캐스팅 하는것은 문제가 없다.</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nf">Stack</span><span class="o">(){</span>
        <span class="c1">// 제네릭 배열 생성, 컴파일 에러 발생!  비구체화 타입을 저장하는 배열은 생성할수 없다.</span>
        <span class="c1">//elements = new E[DEFAULT_INITIAL_CAPACITY];</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="o">(</span><span class="no">E</span><span class="o">[])</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="nc">Object</span> <span class="n">e</span><span class="o">){...}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">pop</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">EmptyStackException</span><span class="o">();</span>
        <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">elements</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
        <span class="n">elements</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 쓸모없는 참조 제거</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 제네릭 적용2 - elements 타입자체를 변경</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;{</span>
    <span class="kd">private</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">elements</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">16</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Stack</span><span class="o">(){</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="no">DEFAULT_INITIAL_CAPACITY</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">push</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">){...}</span>
    <span class="kd">public</span> <span class="no">E</span> <span class="nf">pop</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">EmptyStackException</span><span class="o">();</span>

        <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
        <span class="no">E</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="no">E</span><span class="o">)</span><span class="n">elements</span><span class="o">[--</span><span class="n">size</span><span class="o">];</span>
        <span class="n">elements</span><span class="o">[</span><span class="n">size</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 쓸모없는 참조 제거</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>배열 타입에 대한 unchecked 캐스트 경고를 억제하는게 더 위험하므로 적용2 가 더 좋은 방법 일 수 있다.</li>
  <li>하지만 적용2는  elements 를 사용하는 모든 부분에 캐스팅을 해야하고 @SupressWarnings 를 적용해야 되므로 더 많은일을 해줘야한다.</li>
  <li>Stack 클래스에서는 내부적으로 배열을 사용했다. 배열보다는 List 를 사용하라고 강조했지만 자바 언어 자체는 List 를 지원하지 않으므로 ArrayList 와 같은 일부 제네릭 타입은 내부적으로 배열을 사용한다. HashMap 은 성능 향상을 목적으로 배열을 사용하기도 한다.</li>
  <li>제네릭 타입은 매개변수가 갖는 제약이 전혀없다. Stack&lt;Object&gt; Stack&lt;int[]&gt; Stack&lt;List&lt;String&gt;&gt; 등 여러 형태가 가능하다.
    <ul>
      <li>&lt;E extends Delayed&gt; 같은 바운드 타입 배개변수(bounded type parameter)는 허용가능한 값을 제한할수 있다.</li>
    </ul>
  </li>
  <li>하지만 Stack&lt;int&gt; Stack&lt;double&gt; 같은 기본형은 불가능하다. 박스형 기본형 Integer Double 클래스를 사용하는것이 좋다.</li>
</ul>

<h3 id="item27--가능하면-제네릭-메서드로-만들-것">ITEM27 : 가능하면 제네릭 메서드로 만들 것</h3>
<ul>
  <li>Collections 클래스의 모든 알고리즘 메소드들(binarySearch sort)는 제네릭화 되어있다.</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="c1">// 제네릭이 적용안된 메소드</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Set</span> <span class="nf">union</span><span class="o">(</span><span class="nc">Set</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">Set</span> <span class="n">s2</span><span class="o">){</span>
    <span class="c1">// Warning! HashSet(Collection&lt;? extends E&gt;)</span>
    <span class="nc">Set</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
    <span class="c1">// Warning! result.addAll(Collection&lt;? extends E&gt;)</span>
    <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// 제네릭 적용 메소드</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">union</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">s2</span><span class="o">){</span>
    <span class="nc">Set</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
    <span class="n">result</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>타입매개변수를 선언하는 타입 매개변수 목록을 메소드의 접근 지시자와 반환 타입 사이에 둔다. &lt;E&gt;</li>
  <li>
    <p>반환 타입 Set&lt;E&gt;</p>
  </li>
  <li>제네릭 메소드로 중복 제거</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">anagram</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;();</span> <span class="c1">// 중복된 타입들</span>

<span class="c1">// 제네릭 static 팩토리 메소드</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">newHashMap</span><span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;();</span>
<span class="o">}</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">anagrams</span> <span class="o">=</span> <span class="n">newHashMap</span><span class="o">();</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>
    <p>이런 제네릭 메소드가 기본으로 JDK 있으면 좋지만 없음.</p>
  </li>
  <li>
    <p>제네릭 싱글톤 팩토리</p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="no">T</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 불변적이지만 여러타입에대한 적합한 객체 생성</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="no">IDENTIFY_FUNCTION</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;(){</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">apply</span><span class="o">(</span><span class="nc">Object</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">arg</span><span class="o">;}</span>
<span class="o">}</span>

<span class="c1">// 상태값이 없고 언바운드 타입 매개변수를 갖는다.</span>
<span class="c1">// 따라서 모든 타입에서 하나의 인스턴스를 공유해도 안전</span>
<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">identityFunction</span><span class="o">(){</span>
    <span class="k">return</span> <span class="o">(</span><span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;)</span><span class="no">IDENTIFY_FUNCTION</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// 사용</span>
<span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">sameString</span> <span class="o">=</span> <span class="n">identityFunction</span><span class="o">();</span>
<span class="nc">UnaryFunction</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">sameNumber</span> <span class="o">=</span> <span class="n">identifyFunction</span><span class="o">();</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>재귀적 타입 바운드
    <ul>
      <li>Comparable 인터페이스와 가장 많이 사용</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>
    <p>자신과 비교될수 있는 모든 타입 T</p>
  </li>
  <li>
    <p>캐스팅 없이 메소드를 사용할수 있다는것은 메소드를 제네릭 하게 만들었다는 의미</p>
  </li>
</ul>

<h3 id="item28--한정적-와일드카드를-써서-api-유연성을-높여라">ITEM28 : 한정적 와일드카드를 써서 API 유연성을 높여라</h3>
<ul>
  <li>매개변수화 타입은 불변 타입</li>
  <li>불변(invariant)!! Type1 Type2 에 대해서 List&lt;Tyep1&gt; 은 List&lt;Type2&gt; 의 서브타입도 아니고 슈퍼 타입도 아님</li>
  <li>
    <p>List&lt;Object&gt; 에는 아무거나 저장 가능하지만 List&lt;String&gt; 에는 스트링만 저장 가능</p>
  </li>
  <li>스택 pushAll pop 메소드</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="c1">// 와일드 카드 타입을 사용하지 않는 pushAll - 불충분함!</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">pushAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">){</span>
    <span class="k">for</span><span class="o">(</span><span class="no">E</span> <span class="nl">e:</span> <span class="n">src</span><span class="o">)</span>
        <span class="n">push</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numberStack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;();</span>
<span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="o">..;</span>
<span class="c1">// 에러 메세지 pushAll(Iterable&lt;Number&gt;) in Stack&lt;Number&gt;</span>
<span class="c1">// 불변형(상속관계아님) 이기 때문에 Integer iterable 은들어갈수없다.</span>
<span class="n">numberStack</span><span class="o">.</span><span class="na">pushAll</span><span class="o">(</span><span class="n">integers</span><span class="o">);</span>

<span class="c1">// 와일드 카드 사용하지 않은  popAll 메소드 - 불충분함!</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">popAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">dst</span><span class="o">){</span>
    <span class="k">while</span><span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span>
        <span class="n">dst</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">pop</span><span class="o">());</span>
<span class="o">}</span>
<span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numberStack</span> <span class="o">=</span> <span class="k">new</span> <span class="o">..</span>
<span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">objects</span> <span class="o">=</span> <span class="o">...;</span>
<span class="c1">// 컴파일 에러! Collection&lt;Object&gt; 는 Collection&lt;Number&gt; 의 서브 타입이 아니다!</span>
<span class="n">numberStack</span><span class="o">.</span><span class="na">popAll</span><span class="o">(</span><span class="n">objects</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>바운드 와일드 카드 타입(bounded wildcard type)
    <ul>
      <li>pushAll 에는 E의 Iterable 이 아닌 E의 어떤 서브타입의 Iterable 이 되어야 한다.</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="c1">// 와일드 카드 타입 pushAll 은 E 타입을 생산하므로 extends</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">pushAll</span><span class="o">(</span><span class="nc">Iterable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">){...}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>popAll 메소드의 인자 타입은 E타입을 저장하는 Collection 이 아닌 E의 어떤 수퍼 타입을 저장하는 Collection이 되어야 한다.</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="c1">// 와일드 카드타입 popAll 은 E 타입을 소비하므로 super</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">popAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">dst</span><span class="o">){...}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li><strong>유연성을 극대화 하려면 메소드 인자에 와일드 카드 타입을 사용하자.</strong></li>
  <li>PECS : Producer-&gt;Extends, Consumer-&gt;Super
    <ul>
      <li>T가 생산자를 나타내면 &lt;? extedns T&gt;</li>
      <li>T가 소비자를 나타내면 &lt;? super T&gt;</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="no">E</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">,</span> <span class="no">E</span> <span class="n">initVal</span><span class="o">)</span>
<span class="c1">// E가 생산자 역활을 하는 와일드 카드 타입 변수</span>
<span class="n">statiac</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="no">E</span> <span class="nf">reduce</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">,</span> <span class="no">E</span> <span class="n">initVal</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>
    <p>와일드 카드를 쓰므로 인해 List<Integer> 와 Function<Number> 를 사용해서 reduce 호출 가능하다!</Number></Integer></p>
  </li>
  <li>반환 타입에는 와일드 카드 타입을 사용하지 말자
    <ul>
      <li>유연성 보다는 클라이언트 코드에서 와일드 카드 타입을 사용해야 하는 문제가 생긴다.</li>
      <li>클라이언트 코드에서 와일드 카드 타입 때문에 고민해야 된다면 그 클래스의 API 가 잘못된거다.</li>
    </ul>
  </li>
  <li>명시적 타입 매개변수</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="nf">union</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">s1</span><span class="o">,</span> <span class="no">SET</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">E</span><span class="o">&gt;</span> <span class="n">s2</span><span class="o">){...}</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="o">..</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Dobule</span><span class="o">&gt;</span> <span class="n">doubles</span> <span class="o">=</span> <span class="o">...</span>
<span class="c1">// 컴파일 에러! 타입 추론을 할수가없다.</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">union</span><span class="o">(</span><span class="n">integers</span><span class="o">,</span> <span class="n">doubles</span><span class="o">);</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nc">Union</span><span class="o">.&lt;</span><span class="nc">Number</span><span class="o">&gt;</span><span class="n">union</span><span class="o">(</span><span class="n">integers</span><span class="o">,</span> <span class="n">doubles</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>Comparable&lt;T&gt; 는  T 인스턴스를 소비한다. Comparable&lt;? super T&gt; 로 교체
    <ul>
      <li>Comparator&lt;T&gt; 도 마찬가지</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;&gt;</span> <span class="no">T</span> <span class="nf">max</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">){</span>
    <span class="c1">// 컴파일 에러! Iterator&lt;? extends T&gt; 리턴한다.</span>
    <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="nc">Iterable</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="no">T</span> <span class="n">result</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">while</span><span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>
        <span class="no">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="o">&gt;)</span> <span class="n">result</span> <span class="o">=</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>언바운드 타입 매개변수 vs 언바운드 와일드 카드</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="c1">// 언바운드 타입 매개변수</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">intj</span><span class="o">);</span>
<span class="c1">// 언바운드 와일드 카드</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>public API 라면 언바운드 타입 매개변수를 사용하는것이 좋다.</li>
  <li><strong>메소드 선언부 타입 매개변수가 한번만 나타나면 그것을 와일드 카드로 바꾸면 된다</strong></li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
    <span class="c1">// 컴파일 에러! List&lt;?&gt; 이므로 list 에는 null 제외한 어떤값도 추가할수 없다.</span>
    <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)));</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
    <span class="n">swapHelper</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// private 지원 메소드</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">swapHelper</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">){</span>
    <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))));</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="item29--형-안전-다형성-컨테이너를-쓰면-어떨지-따져보라">ITEM29 : 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라</h3>
<ul>
  <li>컨테이너에 제네릭을 사용하면 컨테이너 당 사용 가능한 타입 매개변수의 숫자가 제한된다. 컨테이너에 들어가는 타입이 결정되어있기 때문에.
    <ul>
      <li>컨테이너 자체보다는 요소의 키에 타입매개변수를 두면 그런 제약을 극복할수 있고 서로 다른 타입의 요소가 저장 될수 있다. 이런 컨테이너를 혼성 컨테이너라고 부른다.</li>
    </ul>
  </li>
  <li>제네릭은 Set Map 그리고 ThreadLocal AtomicReference 같은 단일요소 저장 컨테이너에도 쓰임</li>
  <li>제네틱 타입 시스템을 키(Class&lt;T&gt;)로 사용해서 Map Set을 만듬, 그것을 혼성 컨테이너라고 부름!
    <ul>
      <li>클래스 리터럴 타입 : Class&lt;T&gt;</li>
      <li>컴파일과 런타입 두 시점 모두의 타입정보를 전달될때 그것을 타입토큰(type token)</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="c1">// 타입 안전이 보장되는 혼성 컨테이너 패턴!</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Favorite</span><span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Class</span><span class="o">&lt;?&gt;,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">favorites</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Class</span><span class="o">&lt;?&gt;,</span> <span class="nc">Object</span><span class="o">&gt;();</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">putFavorite</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">,</span> <span class="no">T</span> <span class="n">instance</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">throw</span>
        <span class="n">favorites</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">instance</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">getFavorite</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">){</span>
        <span class="c1">// Map 에는 Object 가 들어있지만 T 타입으로 리턴해야한다.</span>
        <span class="c1">// 런타임시에 동적으로 cast 하는 cast 함수 Class&lt;T&gt; 정보가 있으므로 가능!</span>
        <span class="k">return</span> <span class="n">type</span><span class="o">.</span><span class="na">cast</span><span class="o">(</span><span class="n">favorites</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">type</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>
    <p>Map&lt;Class&lt;?&gt;, Object&gt; 에서 언바운드 와일드 카드 타입때문에 아무것도 Map 에 넣을수 없다고 생각할수 있지만 키값에 와일드 카드가 붙어 있다. 따라서 모든 키가 서로 다른 매개변수화 타입을 가질수 있다! 예를 들어 Class&lt;String&gt;, Class&lt;Integer&gt;</p>
  </li>
  <li>
    <p>혼성 컨테이너 문제</p>
    <ul>
      <li>Class 객체를 원천 타입의 형태로 사용하면 타입 안전이 보장되지 않을수 있다. 해결책은아래!</li>
    </ul>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="c1">// put 메소드, 동적 캐스트를 사용해서 런타임 시의 타입 안전을 획득!</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">putFavorite</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">,</span> <span class="no">T</span> <span class="n">instance</span><span class="o">){</span>
    <span class="n">favorites</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">type</span><span class="o">,</span><span class="n">cast</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>비구체화 타입에 사용 될 수 없다. Favorite 객체를 String 이나 String[] 에는 저장할수 있지만 List&lt;String&gt; 은 저장할수 없다.
    <ul>
      <li>List&lt;String&gt; 에 대한 Class 객체를 얻을수 없다. List&lt;String&gt;.class 구문 에러</li>
      <li>바운드 타입 토큰을 사용하면 해결이 가능하긴하다.</li>
    </ul>
  </li>
  <li>바운드 타입 토큰</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">getAnnotation</span><span class="o">(</span><span class="nc">Class</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">annotationType</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>annotationType 은 Annotation 타입을 나타내는 바운드 타입 토큰이다.</li>
  <li>키가 Annotation타입 이고 타입 안전이 보장되는 혼성 컨테이너</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="kd">static</span> <span class="nc">Annotation</span> <span class="nf">getAnnotation</span><span class="o">(</span><span class="nc">AnnotationElement</span> <span class="n">element</span><span class="o">,</span> <span class="nc">String</span> <span class="n">annotationTypeName</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">annitationType</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 언바운드 타입 토큰</span>
    <span class="k">try</span><span class="o">{</span>
        <span class="n">annotationType</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">annotationTypeName</span><span class="o">);</span>
    <span class="o">}</span><span class="k">catch</span><span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
    <span class="c1">// asSubClass 메소드를 사용해서 언바운드 타입토큰을 바운드 타입 토큰으로</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">annotationType</span><span class="o">.</span><span class="na">asSubClass</span><span class="o">(</span><span class="nc">Annotation</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>Class.forName 은 Class&lt;?&gt; 를 리턴함</li>
  <li>Class&lt;?&gt; 아입을 Class&lt;? extends Annotation&gt; 으로 캐스팅 하기위해 asSubClass 라는 메소드를 사용</li>
</ul>

  </article>

  <!-- Twitter -->
<span class="post-sharing">
  <a href="https://twitter.com/share" class="twitter-share-button" data-size="large">Tweet</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
</span>



<!-- Reddit -->
<span class="post-sharing" style="margin-right: 32px">
  <script type="text/javascript" src="//www.redditstatic.com/button/button1.js"></script>
</span>
<!-- Facebook -->
<span class="post-sharing">
  <div class="fb-share-button" data-href="http://rangken.github.io/blog/2015/effective-java-4/" data-layout="button" style="width: 70px;"></div>
</span>


  <div>
		

    

    
    	<div class="post-related">
			Related: <a href="/blog/2015/effective-java-5/">Effective Java 6장 열거형(enum)과 제네릭</a>
        </div>
    
</div>

  <div class="fb-comments" data-href="http://rangken.github.io/blog/2015/effective-java-4/" data-numposts="5" data-colorscheme="light" data-width="750"></div>


</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Young.k</li>
          <li><a href="mailto:rangken@gmail.com">rangken@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/rangken" target="_blank">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">rangken</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/rangken87" target="_blank">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">rangken87</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
      <!-- footer desctiption <p class="text"></p> -->
      Powered by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a> & <a href="http://jekyllrb.com/" target="_blank">Jekyll</a>
      </div>
    </div>

  </div>
  <div id="fb-root"></div>
</footer>


  </body>

</html>
